using UnityEngine;
using System.Collections;
using TMPro;
using UnityEngine.UI;

public class Customer : MonoBehaviour
{
	[Header("Customer State")]
	[SerializeField] private bool isWaiting = true;
	[SerializeField] private int happiness = 100;
	[SerializeField] private float tipPercentage;
	[SerializeField] private float tipModifier = 1f;

	[Space(10)] 
	[Header("Food Rank")]
	[SerializeField] private EFoodRank foodRank;

	[Space(10)] 
	[Header("Order")]
	[SerializeField] private Image orderImage;
	[SerializeField] private TextMeshProUGUI orderText;
	[SerializeField] private TextMeshProUGUI reactionText;

	[Space(10)] 
	[Header("Menu")]
	[SerializeField] private float menuPrice = 3000f;
	[SerializeField] private ItemAttribute[] menus;

	[Space(10)] 
	[Header("Set Exit Lines")]
	[SerializeField] private string[] goodExitLines = { "최고의 식사였어요!", "칭찬스티커 100개 드릴게요!" };
	[SerializeField] private string[] standardExitLines = { "수고하세요", "잘 먹었습니다" };
	[SerializeField] private string[] badExitLines = { "별점 테러할게요", "장사 이렇게 하지마세요", "퉤퉷, 여길 다신 오나 봐라" };


    private void OnEnable()
    {
        Debug.Log("Customer 오브젝트 활성화됨");
    }

    private void OnDisable()
    {
        Debug.LogWarning($"Customer 오브젝트가 비활성화되었습니다. 호출 위치: {System.Environment.StackTrace}");
    }


    private void Start()
	{
        Debug.Log($"Start: 활성 상태 = {gameObject.activeSelf}");

        Enter();
		StartCoroutine(DecreaseHappiness());

        StartCoroutine(TestCoroutine());

    }

    private void Enter()
	{
		string[] entryLines = { "안녕하세요~", "배고파 죽을뻔 했어요..", "늘 먹던걸로... 네? 모르겠다구요?" };
		orderText.text = entryLines[Random.Range(0, entryLines.Length)];

		Invoke("OrderMenu", Random.Range(2f, 10f));
	}

    private IEnumerator TestCoroutine()
    {
        Debug.Log("TestCoroutine 시작됨");
        yield return new WaitForSeconds(1f);
        Debug.Log("TestCoroutine 완료");
    }

    private IEnumerator DecreaseHappiness()
	{
		while (isWaiting && happiness > 0)
		{
			yield return new WaitForSeconds(1f);
			happiness--;

			if (happiness <= 50) tipModifier = 0.5f;
		}
	}

	private void OrderMenu()
	{
		isWaiting = false;
		orderImage.gameObject.SetActive(true);

		int random = Random.Range(0, menus.Length);
		orderText.text = $"{menus[random].ItemName}(으)로 주세요!";
		orderImage.sprite = menus[random].ItemImage;
	}

    private bool isExiting = false;

    public void ServeMenu()
    {
        if (foodRank == EFoodRank.None)
        {
            Debug.LogError("EFoodRank가 설정되지 않았습니다. 기본값 Bad로 설정됩니다.");
            foodRank = EFoodRank.Bad;
        }

        switch (foodRank)
        {
            case EFoodRank.Good:
                tipPercentage = Random.Range(0.2f, 0.3f) * tipModifier;
                break;
            case EFoodRank.Standard:
                tipPercentage = 0f;
                break;
            case EFoodRank.Bad:
                tipPercentage = -0.5f * tipModifier;
                break;
        }

        Debug.Log($"ServeMenu: 활성 상태 = {gameObject.activeSelf}, Hierarchy 상태 = {gameObject.activeInHierarchy}");

        if (gameObject.activeSelf && gameObject.activeInHierarchy)
        {
            Debug.Log("ServeMenu: StartCoroutine 실행 준비됨");

            // 강제 비활성화 및 재활성화
            gameObject.SetActive(false);
            StartCoroutine(ReenableAndStartEating());
        }
        else
        {
            Debug.LogError("ServeMenu: 오브젝트 활성화 상태가 비정상적입니다.");
        }
    }

    private IEnumerator ReenableAndStartEating()
    {
        yield return new WaitForEndOfFrame(); // 한 프레임 대기
        gameObject.SetActive(true);          // 강제로 재활성화
        Debug.Log("ReenableAndStartEating: 재활성화 완료");
        StartCoroutine(nameof(Eating));     // Eating 코루틴 호출
    }


    private IEnumerator Eating()
	{
        Debug.Log($"Eating 시작: 활성 상태 = {gameObject.activeSelf}");

        string[] reactions = { "냠냠..", "쩝쩝..", "음.." };
		Vector3[] positions =
		{
			new Vector3(-200f, -50f, 0f),
			new Vector3(-400f, -100f, 0f),
			new Vector3(-200f, -160f, 0f)
		};

		float eatingTime = Random.Range(10f, 20f);
		float elapsedTime = 0f;
		int reactionIndex = 0;

		orderImage.gameObject.SetActive(false);
		reactionText.gameObject.SetActive(true);

		while (elapsedTime < eatingTime)
		{
			reactionText.text = reactions[reactionIndex];
			reactionText.transform.localPosition = positions[reactionIndex];
			reactionIndex = (reactionIndex + 1) % reactions.Length;

			yield return new WaitForSeconds(1f);
			elapsedTime += 1f;
            Debug.Log($"Eating 진행 중: 활성 상태 = {gameObject.activeSelf}");
        }

		reactionText.gameObject.SetActive(false);
		StartCoroutine(Exit());
	}

	private void SetTipPercentage()
	{
		switch (foodRank)
		{
			case EFoodRank.Good:
				tipPercentage = Random.Range(0.2f, 0.3f) * tipModifier;
				break;
			case EFoodRank.Standard:
				tipPercentage = 0f;
				break;
			case EFoodRank.Bad:
				tipPercentage = -0.5f * tipModifier;
				break;
		}
	}

    private IEnumerator Exit()
    {
        if (isExiting) yield break;
        isExiting = true;

        SetTipPercentage();

        float finalPrice = Mathf.FloorToInt(menuPrice * tipPercentage) + menuPrice;
        orderText.text = $"여기요! +{finalPrice}";
        yield return new WaitForSeconds(3f);

        ShowExitReaction();
        yield return new WaitForSeconds(3f);

        Debug.Log("손님이 떠났습니다.");
        gameObject.SetActive(false);
        isExiting = false;
    }

    private void ShowExitReaction()
	{
		string[] exitLines = foodRank switch
		{
			EFoodRank.Good => goodExitLines,
			EFoodRank.Standard => standardExitLines,
			EFoodRank.Bad => badExitLines,
			_ => throw new System.Exception("Unknown food rank")
		};

		orderText.text = exitLines[Random.Range(0, exitLines.Length)];
	}
}
